---
title: "给个面子过了吧"
date: "2023-03-12T09:38:18Z"
---
"---
title: \"测试文章\"
date: \"2023-03-12T06:45:08Z\"
---
\"[vue<span class=\\"i-logos-vue\\"></span>](./tests/mark.md)
通过代理给对象进行增强，之后无论是访问代理对象还是访问源对象都会有相同的属性，但是访问源对象并不会用上代理的增强属性。
Proxy代理生成的对象没有原型，其原型为undefined。
如果想要重写代理中的捕获器的行为需要使用Reflect来进行重写。
```js
const target = {
 foo: 'bar',
 baz: 'qux'
};

const handler = {
 get(trapTarget, poperty, reciver) {
 let decoration = '';
 if (poperty === 'foo') { 
 decoration = '!!!';
 }
 return Reflect.get(...arguments) + decoration;
 }
}

const proxy = new Proxy(target, handler);
console.log(proxy.foo);
console.log(proxy.baz);
```
- 可撤销代理
const {proxy, revoke} = Proxy.revocable(target, handler);
之后执行revoke()就可以进行代理的撤销。
- 反射API
 - Reflect.defineProperty()
 - Reflect.preventExtensions()
 - Reflect.setPrototypeOf()
 - Reflect.set()
 - Reflect.deleteProperty()
在调用方法失败时不会报错而是返回true or false标记。
- 可以代理代理代理
- 代理的问题
 - this指向
 如果类使用WeakMap来进行属性的设置，则在代理实例后，会出现代理无法访问实例中属性的情况存在，这个时候需要使用代理类，之后通过代理类进行操作。
 - 代理内部类
 比如代理Date对象，在使用其方法时，会出现错误情况，因为Proxy中并没有Date类的独有属性。

## 代理捕获方法

### get()
接收： 
- target：目标对象
- property：对象上的属性
- receiver：继承代理对象的对象
### set()
接收：
- target：目标对象
- property：对象上的属性
- value：要赋给属性的值
- receiver：接收最初赋值的对象
返回布尔表示执行是否成功。
### has()
接收：
- target：目标对象
- property：对象上的属性
返回布尔表示属性是否存在。
### defineProperty()
接收：
- target：目标对象
- property：对象上的属性
- descriptor：
返回布尔表示执行是否成功。
[MoreDetial](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\"
"
